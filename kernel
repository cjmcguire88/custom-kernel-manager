#!/usr/bin/env bash

# Exit on error
exoe() {
    echo -e "\033[1;31m${1}\033[0m" >&2
    if ((${#K_FILES[@]})); then
        echo "Cleaning up..."
        for file in ${K_FILES[@]}; do
            rm -rf $file
        done
    fi
    exit 1
}
# -c: This function downloads the changelog for the kernel version passed to it.
# It then displays the changelog using cat or neovim.
k_cl() {
    MAJ_VER="${1:0:1}"
    [[ "$1" =~ ^[0-9]+\.[0-9]+\.?[0-9]*$ ]] || exoe "Not a valid kernel version"
    echo -e "\n\033[1;37mRetrieving linux-${1} Changelog\033[0m"
    case $DOWNLOADER in
        1)
            sudo -i -u $SUDO_USER wget $PROTO://cdn.kernel.org/pub/linux/kernel/v${MAJ_VER}.x/ChangeLog-${1} -P $RUN_DIR > /dev/null 2>&1 || exoe "$1 not found"
            ;;
        2)
            sudo -i -u $SUDO_USER aria2c -x 3 -m 3 -d $RUN_DIR $PROTO://cdn.kernel.org/pub/linux/kernel/v${MAJ_VER}.x/ChangeLog-${1} > /dev/null 2>&1 || exoe "$1 not found"
            ;;
        3)
            sudo -i -u $SUDO_USER curl -sL -o $RUN_DIR/ChangeLog-${1} $PROTO://cdn.kernel.org/pub/linux/kernel/v${MAJ_VER}.x/ChangeLog-${1}
    esac
    sudo -i -u $SUDO_USER $CL_VIEWER $RUN_DIR/ChangeLog-${1}
    rm -rf $RUN_DIR/ChangeLog-${1}
}
# -b: This function checks for a backups directory in $SRC_DIR and if it doesn't exist,
# creates it. It checks whether the kernel version passed to it already has a backup,
# and creates one using tar with gzip in the backups directory. Called from k_remove.
k_backup() {
    [[ ! -d $SRC_DIR/backups ]] && mkdir $SRC_DIR/backups
    [[ -f $SRC_DIR/backups/${1}.tar.gz ]] && exoe "Archive already exists"
    [[ ! -d $SRC_DIR/linux-${1} ]] && exoe "\033[0mlinux-${1}\033[1;31m not installed"
    echo -e "\n\033[1;37m$SRC_DIR/\033[1;32mlinux-${1}\033[1;37m > $SRC_DIR/backups/\033[1;34m${1}.tar.gz\033[0m"
    tar -czvf $SRC_DIR/backups/${1}.tar.gz -C $SRC_DIR/ linux-${1}
    echo -e "\nArchive \033[0;32m${1}.tar.xz\033[0m created in $SRC_DIR/backups"
}
# -p: This function downloads patches from links contained in a txt file called
# patchfile, to the patches directory it creates. It is called from k_prepare.
k_patch() {
    echo -e "\n\033[1;37mRetrieving patches\033[0m"
    mkdir patches
    cd patches || exoe "patches directory missing"
    case $DOWNLOADER in
        1)
            wget -i $PATCH_DIR/patchfile || exoe "No patchfile or patches directory"
            ls
            ;;
        2)
            aria2c -i $PATCH_DIR/patchfile || exoe "No patchfile or patches directory"
            ;;
        3)
            xargs -n 1 curl -O < $PATCH_DIR/patchfile
            ls
            ;;
    esac
    read -n 1 -p $'\033[1;37mAre these the correct patches \033[0m[Y/n]: ' REPLY
    echo
    [[ $REPLY =~ ^[Nn]$ ]] && exit
    echo -e "\n\033[1;37mpatches -> \033[0m$(pwd)"
    cd ../
}
# -r: This function will remove all files associated with the kernel version passed
# to it. First it will ask if you'd like to make a compressed backup of the kernel
# source directory via k_backup. It will then list the files that were found before
# confirming deletion.
k_remove() {
    [[ "$1" =~ ^[0-9]+?\.{1}[0-9]+?\.{1}[0-9]+?-??[0-9a-zA-Z\-]*?$ ]] || exoe "Not a valid kernel version"
    [[ "$1" =~ $(uname -r) ]] && exoe "${1} is the currently running kernel"
    if [[ -d /usr/src/linux-${1} ]]; then
        read -n 1 -p $'\033[1;37mCreate a compressed archive of kernel source? \033[0m[y/N]: ' REPLY
        case ${REPLY:-N} in
            [yY])
                k_backup ${1}
                ;;
            *)
                echo -e "\nSkipping backup. (\033[1;31mKernel files will not be recoverable after deletion!\033[0m)"
                ;;
        esac
    fi
    echo -e "\n\033[1;33mThe following files and directories will be permanently deleted:\033[0m"
    for file in $KERNEL_DIR/*${1}*; do
        [[ -e $file ]] || continue
        echo -e "$KERNEL_DIR/\033[0;31m$(echo "$file" | cut -d "/" -f3-)\033[0m"
        rmf+=( "$file" )
    done
    for file in $SRC_DIR/*${1}*; do
        [[ -e $file ]] || continue
        echo -e "$SRC_DIR/\033[0;31m$(echo "$file" | cut -d "/" -f4-)\033[0m"
        rmf+=( "$file" )
    done
    for file in /usr/lib/modules/*${1}*; do
        [[ -e $file ]] || continue
        echo -e "/usr/lib/modules/\033[0;31m$(echo "$file" | cut -d "/" -f5-)\033[0m"
        rmf+=( "$file" )
    done
    for file in /etc/mkinitcpio.d/*${1}*; do
        [[ -e $file ]] || continue
        echo -e "/etc/mkinitcpio.d/\033[0;31m$(echo "$file" | cut -d "/" -f4-)\033[0m"
        rmf+=( "$file" )
    done
    if [ ${#rmf[@]} -eq 0 ]; then
       exoe "No files to remove"
    fi
    [[ ! -f $SRC_DIR/backups/${1}.tar.gz ]] && echo -e "\n\033[0;31mNo backup exists!\033[0m"
    read -n 1 -p $'\n\033[0;33mAre you sure?\033[0m [y/N]: ' REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Check for and remove any files containing specified kernel version in these directories
        for file in ${rmf[@]}; do
            rm -rf $file
        done
        echo -e "\n\033[1;37mAll \033[0mlinux-${1}\033[1;37m kernel files removed from system.\033[0m"
        echo -e "\nBe sure to update the bootloader.\nGrub: \033[0;32msudo grub-mkconfig -o $KERNEL_DIR/grub/grub.cfg\033[0m\nSystemd-boot: Edit necessary config files."
    else
        echo -e "\nNo files were deleted"
    fi
}
# -a: This function will restore the backup of the kernel version passed to it
# provided one was made using -b (k_backup). It first decompresses the .tar.gz
# archive with the kernels name into $SRC_DIR. It then calls k_install to reinstall
# the kernel.
k_restore() {
    [[ ! -f $SRC_DIR/backups/${1}.tar.gz ]] && exoe "No backup file for ${1}"
    echo -e "\033[1;37mRestoring \033[0;32mlinux-${1}\033[0m"
    tar -xzf $SRC_DIR/backups/${1}.tar.gz -C $SRC_DIR/
    cd $SRC_DIR/linux-${1} || exoe "Source directory missing"
    k_install ${1}
}
# -n: This function will check for the newest stable and longterm versions on kernel.org.
# You can then choose which one to install.
k_new() {
    case $DOWNLOADER in
        1)
            wget -P $RUN_DIR $PROTO://www.kernel.org > /dev/null 2>&1
            ;;
        2)
            aria2c -x 3 -m 3 -d $RUN_DIR $PROTO://www.kernel.org > /dev/null 2>&1
            ;;
        3)
            curl -o $RUN_DIR/index.html $PROTO://www.kernel.org > /dev/null 2>&1
            ;;
    esac
    STABLE=$(grep -A3 -m1 '<td>stable:</td>' $RUN_DIR/index.html)
    SVER=$(echo $STABLE | awk -F '[><]' '{print $9}')
    SDATE=$(echo $STABLE | awk -F '[><]' '{print $15}')
    LONGTERM=$(grep -A3 -m1 '<td>longterm:</td>' $RUN_DIR/index.html)
    LVER=$(echo $LONGTERM | awk -F '[><]' '{print $9}')
    LDATE=$(echo $LONGTERM | awk -F '[><]' '{print $15}')
    echo -e "1. STABLE: \033[1;32m$SVER\033[0m $SDATE\n"
    echo -e "2. LONGTERM: \033[1;32m$LVER\033[0m $LDATE\n"
    read -n 1 -p "Choose one (default=1): " REPLY
    case ${REPLY:-1} in
        1)
            VERS=$SVER
            ;;
        2)
            VERS=$LVER
            ;;
        *)
            exoe "Invalid selection"
            ;;
    esac
    k_prepare $VERS
    if [[ -f $SRC_DIR/linux-$VERS.tar.xz ]]; then
        echo -e "\n\033[1;37mCleaning up\033[0m\n"
        rm -rf $SRC_DIR/linux-${VERS}.tar.xz
    fi
    rm -rf $RUN_DIR/index.html
}
# -i: This function asks for the name of the new kernel then downloads the kernel
# source from kernel.org. If you choose yes to patching it will either check for
# a folder containing patches in the callers home directory or calls k_patch to
# download them. It then adds the name chosen to the makefile and removes the line
# from init/kconfig that prohibits -o3 optimization. Then it copies the config from
# the kernel specified by uname -r and asks if you'd like to open the kernel config
# menu (menuconfig) to make any changes to the configuration. Finally it compiles
# the kernel using 75% of the computers processor cores before passing it over to
# k_install. Called from k_update.
k_prepare() {
    VERS="$1"
    MAJ_VER="${1:0:1}"

    if [[ $(echo ${VERS} | awk -F "." '{print NF}') -lt 3 ]]; then
        MVERS=${VERS}.0
    else
        MVERS=${VERS}
    fi
    [[ "$VERS" =~ ^[0-9]+\.[0-9]+\.?[0-9]*$ ]] || exoe "Not a valid kernel version"
    cd $SRC_DIR
    read -r -p $'\n\033[1;37mEnter kernel name (eg linux-'"${MVERS}"$'-\033[1;32mNAME\033[1;37m): \033[0m' NAME
    echo -e "\n\033[1;37mKernel name set to \033[1;32mlinux-${MVERS}-$NAME\033[0m"
    if [[ -f $SRC_DIR/linux-${VERS}.tar.xz ]]; then
        echo -e "\n\033[1;37mlinux-${VERS}.tar.xz already exists. Skipping download.\033[0m\n"
    else
        k_download $VERS
    fi
    echo -e "\033[1;37mUnpacking tarball\033[0m\n"
    tar -xJf linux-${VERS}.tar.xz && mv linux-${VERS} linux-${MVERS}-$NAME
    cd linux-${MVERS}-$NAME || exoe "Missing kernel directory"
    read -n 1 -p $'\033[1;37mPatch the kernel? \033[0m[Y/n]: ' REPLY
    echo
    case ${REPLY:-Y} in
        [Yy])
            if [[ -d $PATCH_DIR/patches ]]; then
                cp -r $PATCH_DIR/patches $SRC_DIR/linux-${MVERS}-$NAME/
                echo
            else
                k_patch || exoe "Failed to retrieve patches"
            fi
            echo -e "\n\033[1;37mPatching Kernel\033[0m"
            for i in patches/*; do echo -e "\033[1;37mApplying: \033[1;32m${i//patches\/}\033[0m"; patch -p1 < $i; echo; done || exoe "Patching failed"
            ;;
        *)
            echo "skipping"
            ;;
    esac
    echo -e "\n\033[1;37mEditing Makefile\033[0m\n"
    sed -i "s/^EXTRAVERSION =.*$/& -$NAME/g" Makefile
    echo -e "\033[1;37mUnlocking -O3 optimization\033[0m"
    sed -i '/bool "Optimize more for performance (-O3)"/{n;d}' init/Kconfig
    read -n 1 -p $'\n\033[1;37mCopy config from currently running kernel? \033[0m[Y/n]: ' REPLY
    echo
    case ${REPLY:-Y} in
        [Yy])
            echo -e "\n\033[1;37mGenerating kernel config\033[0m"
            cp -v $SRC_DIR/linux-$(uname -r)/.config ./
            make oldconfig || exoe "Failed to generate config"
            read -n 1 -p $'\n\033[1;37mOpen kernel configuration menu? \033[0m[y/N]: ' REPLY
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                make menuconfig
            fi
            ;;
        *)
            echo -e "\n\033[0;32m
            localmodconfig creates a config based on current config and loaded
            modules (lsmod). Disables any module option that is not needed for
            the loadedmodules. You can plug in everything that you'll be using
            on the machine and it will load all needed modules for all devices
            it detects. Or enable any needed modules for devices not currently
            connected in the configuration menu.\033[0m"
            read -n 1 -p $'\n\033[1;37mRun make localmodconfig before opening configuration menu?\033[0m[y/N]: ' REPLY
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                make localmodconfig
            fi
            echo -e "\033[1;37mOpening kernel configuration menu.\033[0m"
            make menuconfig
            ;;
    esac
    echo -e "\033[1;37mCompiling ${1}\033[0m"
    make -j$(($(nproc) - $(nproc) / 4)) || exoe "Compilation failed"
    k_install ${MVERS}-${NAME}
}
# Not called directly by the user: This function is called by -a (k_restore)
# and -i (k_prepare). First it copies the bzImage (the kernel binary) to
# the necessary directories. Then it installs the kernel modules, creates
# a .preset file which is used by mkinitcpio to generate the initramfs
# which is then copied into the necessary directories.
k_install() {
    K_FILES+=( "$SRC_DIR/linux-${1}" )
    echo -e "\033[1;37mInstalling ${1}\033[0m"
    cp -v $SRC_DIR/linux-${1}/arch/x86_64/boot/bzImage $KERNEL_DIR/vmlinuz-linux-${1}
    K_FILES+=( "$KERNEL_DIR/vmlinuz-linux-${1}" )
    echo -e "\n\033[1;37mInstalling modules\033[0m\n"
    make modules_install
    K_FILES+=( "/usr/lib/modules/${1}" )
    case $INITRD in
        mkinitcpio)
            echo -e "\n\033[1;37mGenerating initramfs\033[0m\n"
            cd /etc/mkinitcpio.d/ || exoe "mkinitcpio preset directory not found"
            cp linux-$(uname -r).preset linux-${1}.preset
            K_FILES+=( "/etc/mkinitcpio.d/linux-${1}.preset" )
            sed -i "s/$(uname -r)/${1}/g" linux-${1}.preset
            mkinitcpio -p linux-${1}
            for file in $KERNEL_DIR/initramfs-${1}*; do
                K_FILES+=( "$file" )
            done
            ;;
        dracut)
            echo -e "\n\033[1;37mGenerating initramfs\033[0m\n"
            dracut --kver ${1} --hostonly --no-hostonly-cmdline $KERNEL_DIR/initramfs-linux-${1}.img
            for file in $KERNEL_DIR/initramfs-${1}*; do
                K_FILES+=( "$file" )
            done
            ;;
        none)
            echo "Skipping initramfs creation"
    esac
    echo -e "\n\033[1;37mThe following files have been installed to the system:\n"
    for file in ${K_FILES[@]}; do
        echo -e "$file"
    done
    echo -e "\nBe sure to update the bootloader.\nGrub: \033[0;32msudo grub-mkconfig -o $KERNEL_DIR/grub/grub.cfg\033[0m\nSystemd-boot: Edit necessary config files."
    if [[ -e /home/$SUDO_USER/.config/kernel/hooks ]]; then
        read -r -p '\n\033[1;37mRun post-installation hooks? \033[0m[y/N] ' REPLY
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            source /home/$SUDO_USER/.config/kernel/hooks
        fi
    fi
}
# Get Linux kernel tarball and cryptographically verify it,
# retrieving the PGP keys using the Web Key Directory (WKD)
# protocol if they are not already in the keyring.
k_download() {
    echo -e "\n\033[1;37mDownloading linux-${VERS}\033[0m"
    VER=${1}
    MAJOR="$(echo ${VER} | cut -d. -f1)"
    if [[ ${MAJOR} -lt 3 ]]; then
        exoe "This script only supports kernel v3.x.x and above"
    fi

    if [[ ! -d ${SRC_DIR} ]]; then
        exoe "${SRC_DIR} does not exist"
    fi

    TARGET="${SRC_DIR}/linux-${VER}.tar.xz"
    # Do we already have this file?
    if [[ -f ${TARGET} ]]; then
        echo "File ${SRC_DIR}/linux-${VER}.tar.xz already exists."
        exit 0
    fi

    if [[ ! -x ${GPGBIN} ]]; then
        exoe "Could not find gpg in ${GPGBIN}"
    fi
    if [[ ! -x ${GPGVBIN} ]]; then
        exoe "Could not find gpgv in ${GPGVBIN}"
    fi

    TMPDIR=$(mktemp -d ${SRC_DIR}/linux-tarball-verify.XXXXXXXXX.untrusted)
    echo "Using TMPDIR=${TMPDIR}"
    if [[ -z ${USEKEYRING} ]]; then
        if [[ -z ${GNUPGHOME} ]]; then
            GNUPGHOME="${TMPDIR}/gnupg"
        elif [[ ! -d ${GNUPGHOME} ]]; then
            echo "GNUPGHOME directory ${GNUPGHOME} does not exist"
            echo -n "Create it? [Y/n]"
            read YN
            if [[ ${YN} == 'n' ]]; then
                rm -rf ${TMPDIR}
                exoe "Exiting" 1
            fi
        fi
        mkdir -p -m 0700 ${GNUPGHOME}
        echo "Making sure we have all the necessary keys"
        ${GPGBIN} --batch --quiet \
            --homedir ${GNUPGHOME} \
            --auto-key-locate wkd \
            --locate-keys ${DEVKEYS} ${SHAKEYS}
        if [[ $? != "0" ]]; then
            rm -rf ${TMPDIR}
            exoe "Something went wrong fetching keys"
        fi
        USEKEYRING=${TMPDIR}/keyring.gpg
        ${GPGBIN} --batch --export ${DEVKEYS} ${SHAKEYS} > ${USEKEYRING}
    fi
    SHAKEYRING=${TMPDIR}/shakeyring.gpg
    ${GPGBIN} --batch \
        --no-default-keyring --keyring ${USEKEYRING} \
        --export ${SHAKEYS} > ${SHAKEYRING}
    DEVKEYRING=${TMPDIR}/devkeyring.gpg
    ${GPGBIN} --batch \
        --no-default-keyring --keyring ${USEKEYRING} \
        --export ${DEVKEYS} > ${DEVKEYRING}

    TXZ="$PROTO://cdn.kernel.org/pub/linux/kernel/v${MAJOR}.x/linux-${VER}.tar.xz"
    SIG="$PROTO://cdn.kernel.org/pub/linux/kernel/v${MAJOR}.x/linux-${VER}.tar.sign"
    SHA="$PROTO://www.kernel.org/pub/linux/kernel/v${MAJOR}.x/sha256sums.asc"

    SHAFILE=${TMPDIR}/sha256sums.asc
    echo "Downloading the checksums file for linux-${VER}"
    case $DOWNLOADER in
        1)
            wget -q ${SHA} -P ${TMPDIR} || { rm -rf ${TMPDIR}; exoe "Failed to download the checksums file"; }
            ;;
        2)
            aria2c -q -x 3 -m 3 -d ${TMPDIR} ${SHA} || { rm -rf ${TMPDIR}; exoe "Failed to download the checksums file"; }
            ;;
        3)
            curl -sL -o ${SHAFILE} ${SHA} || { rm -rf ${TMPDIR}; exoe "Failed to download the checksums file"; }
            ;;
    esac
    echo "Verifying the checksums file"
    COUNT=$(${GPGVBIN} --keyring=${SHAKEYRING} --status-fd=1 ${SHAFILE} \
            | grep -c -E '^\[GNUPG:\] (GOODSIG|VALIDSIG)')
    if [[ ${COUNT} -lt 2 ]]; then
        rm -rf ${TMPDIR}
        exoe "FAILED to verify the sha256sums.asc file."
    fi
    SHACHECK=${TMPDIR}/sha256sums.txt
    grep "linux-${VER}.tar.xz" ${SHAFILE} > ${SHACHECK}

    echo
    echo "Downloading the signature file for linux-${VER}"
    SIGFILE=${TMPDIR}/linux-${VER}.tar.asc
    case $DOWNLOADER in
        1)
            wget -q ${SIG} -O ${SIGFILE} || { rm -rf ${TMPDIR}; exoe "Failed to download the signature file"; }
            ;;
        2)
            aria2c -q -x 3 -m 3 -d ${TMPDIR} -o linux-${VER}.tar.asc ${SIG} || { rm -rf ${TMPDIR}; exoe "Failed to download the signature file"; }
            ;;
        3)
            curl -sL -o ${SIGFILE} ${SIG} || { rm -rf ${TMPDIR}; exoe "Failed to download the signature file"; }
            ;;
    esac
    echo "Downloading the XZ tarball for linux-${VER}"
    TXZFILE=${TMPDIR}/linux-${VER}.tar.xz
    case $DOWNLOADER in
        1)
            wget ${TXZ} -P ${TMPDIR} || { rm -rf ${TMPDIR}; exoe "Failed to download the tarball"; }
            ;;
        2)
            aria2c -x 3 -m 3 -d ${TMPDIR} ${TXZ} || { rm -rf ${TMPDIR}; exoe "Failed to download the tarball"; }
            ;;
        3)
            curl -sL -o ${TXZFILE} ${TXZ} || { rm -rf ${TMPDIR}; exoe "Failed to download the tarball"; }
            ;;
    esac
    pushd ${TMPDIR} >/dev/null
    echo "Verifying checksum on linux-${VER}.tar.xz"
    if ! ${SHA256SUMBIN} -c ${SHACHECK}; then
        popd >/dev/null
        rm -rf ${TMPDIR}
        exoe "FAILED to verify the downloaded tarball checksum"
    fi
    popd >/dev/null

    echo
    echo "Verifying developer signature on the tarball"
    COUNT=$(${XZBIN} -cd ${TXZFILE} \
            | ${GPGVBIN} --keyring=${DEVKEYRING} --status-fd=1 ${SIGFILE} - \
            | grep -c -E '^\[GNUPG:\] (GOODSIG|VALIDSIG)')
    if [[ ${COUNT} -lt 2 ]]; then
        rm -rf ${TMPDIR}
        exoe "FAILED to verify the tarball!"
    fi
    mv -f ${TXZFILE} ${TARGET}
    rm -rf ${TMPDIR}
    echo
    echo "Successfully downloaded and verified ${TARGET}"
}
# compares the currently running version to the version on kernel.org
isUpdate() {
    IFS='.' read -r -a NEW <<< "$1"
    IFS='.' read -r -a INSTALLED <<< "$2"
    if [[ ${NEW[1]} -gt ${INSTALLED[1]} ]]; then
        return 0
    elif [[ ${NEW[2]} -le ${INSTALLED[2]} ]]; then
        return 1
    else
        return 0
    fi
}
# -u: This function downloads the kernel.org webpage and finds the link
# for the latest stable kernel which it passes to k_prepare for download and
# installation. It will first ask to display the changelog for the kernel
# via k_cl.
k_update() {
    echo -e "\033[1;37mGetting latest kernel version...\033[0m"
    case $DOWNLOADER in
        1)
            VERS=$(wget -P $RUN_DIR $PROTO://www.kernel.org/finger_banner > /dev/null 2>&1 && awk '{print $NF}' $RUN_DIR/finger_banner | head -n 1 && rm -f $RUN_DIR/finger_banner*)
            ;;
        2)
            VERS=$(aria2c -q -x 3 -m 3 -d $RUN_DIR $PROTO://www.kernel.org/finger_banner > /dev/null 2>&1 && awk '{print $NF}' $RUN_DIR/finger_banner | head -n 1 && rm -f $RUN_DIR/finger_banner*)
            ;;
        3)
            VERS=$(curl -o $RUN_DIR/finger_banner $PROTO://www.kernel.org/finger_banner > /dev/null 2>&1 && awk '{print $NF}' $RUN_DIR/finger_banner | head -n 1 && rm -f $RUN_DIR/finger_banner*)
            ;;
    esac
    CURRENT_VERS=$(uname -r | awk -F "-" '{print $1}')

    if [[ $(echo ${VERS} | awk -F "." '{print NF}') -lt 3 ]]; then
        MVERS=${VERS}.0
    else
        MVERS=${VERS}
    fi
    if isUpdate $MVERS $CURRENT_VERS; then
        echo -e "\033[1;32m$CURRENT_VERS\033[0m -> \033[1;32m$VERS\n"
        read -t 10 -n 1 -p $'\033[1;37mView kernel changelog? \033[0m[y/N]: ' REPLY
        case ${REPLY:-N} in
            [yY])
                k_cl $VERS
                ;;
            *)
                echo -e "\nskipping"
                ;;
        esac
        read -t 10 -n 1 -p $'\n\033[1;37mWould you like to update? \033[0m[y/N]: ' REPLY
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            exit
        fi
        k_prepare $VERS
        if [[ -f $SRC_DIR/linux-$VERS.tar.xz ]]; then
            echo -e "\n\033[1;37mCleaning up\033[0m\n"
            rm -rf $SRC_DIR/linux-${VERS}.tar.xz
        fi
    else
        echo -e "\033[1;37mNewest stable version (\033[1;32m$CURRENT_VERS\033[1;37m) is already installed\033[0m"
        rm -rf $RUN_DIR/*.html
        exit
    fi
}
# Displayed when no arguments are passed: Displays kernel info.
k_info() {
    M_TIME=$(stat $SRC_DIR/linux-$(uname -r)/arch/x86_64/boot/bzImage | grep Modify: | awk -F " " '{print $2}')
    KERNELS=$(ls $KERNEL_DIR/vmlinuz-linux*)
    BACKUPS=$(ls $SRC_DIR/backups)

    echo -e "\033[1;37mKernel version: \033[1;32mlinux-$(uname -r)\033[0m"
    echo -e "\033[1;37mKernel source directory:\033[0m $SRC_DIR/linux-$(uname -r)/"
    echo -e "\033[1;37mCompiled on: \033[0m$M_TIME\n"
    echo -e "\033[1;37mPatches applied:\033[0m\n$(ls $SRC_DIR/linux-$(uname -r)/patches/)\n"
    echo -e "\033[1;37mInstalled kernels \033[0m($KERNEL_DIR)\033[1;37m:\033[0m"
    printf '%s\n' "${KERNELS//\/boot\/vmlinuz-}"
    if [[ ! -z $(ls $SRC_DIR/backups/) ]]; then
        echo -e "\n\033[1;37mKernel backups \033[0m($SRC_DIR/backups)\033[1;37m:\033[0m"
        printf '%s\n' "${BACKUPS}"
    fi
    echo
    echo "Run with -h to see options."
}
# -h: The help menu.
k_help() {
    echo -e "Usage: kernel [-flag] [OPTIONAL_ARG]"
    echo -e "Custom kernel maintenance.\n"
    echo -e "-d   Download the kernel version passed as an argument. (Downloads to SRC_DIR)"
    echo -e "-i   Install the kernel version passed as an argument."
    echo -e "-b   Create a .tar.gz archive of the kernel source directory. Can be restored with -a."
    echo -e "-r   Remove a kernel (passed as argument) from system."
    echo -e "-a   Restore a kernel (passed as an argument) that was backed up then removed."
    echo -e "-c   View the kernel changelog for the version passed as an argument."
    echo -e "-p   Dump a directory containing the patches listed in patchfile given (used for testing)."
    echo -e "-u   Update the kernel to the latest stable on kernel.org."
    echo -e "-n   Create a new kernel. Choose between stable and LTS."
    echo -e "-h   Show this dialogue."
    echo -e "\nAuthor: Jason McGuire"
}
# This is the "main portal" to the above functions.
main() {
    source /home/$SUDO_USER/.config/kernel/kernel.conf
    while getopts ':d:i:b:r:a:c:punh' flag
    do
        case "${flag}" in
            d)
                k_download ${OPTARG}; exit
                ;;
            i)
                k_prepare ${OPTARG}; exit
                ;;
            b)
                k_backup ${OPTARG}; exit
                ;;
            r)
                k_remove ${OPTARG}; exit
                ;;
            a)
                k_restore ${OPTARG}; exit
                ;;
            c)
                k_cl ${OPTARG}; exit
                ;;
            p)
                k_patch; exit
                ;;
            u)
                k_update; exit
                ;;
            n)
                k_new; exit
                ;;
            h)
                k_help; exit
                ;;
            :)
                exoe "Requires argument:\033[0m see -h"
                ;;
            *)
                exoe "Invalid Usage:\033[0m see -h"
                ;;
        esac
    done
    k_info
}
# Since this script requires root privileges for most of its
# operations, this function ensures that it has root privileges
# Then it checks if the config file exists before proceeding to
# main.
if [ "$EUID" -ne 0 ]; then
    exoe "Must be run as root"
elif [[ ! -f /home/$SUDO_USER/.config/kernel/kernel.conf ]]; then
    exoe "Can't find configuration file."
else
    main "$@"
fi
